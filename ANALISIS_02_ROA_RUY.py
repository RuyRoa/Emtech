# -*- coding: utf-8 -*-# Se importa la librería csv para poder leer este tipo de archivosimport csv"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""TRABAJO CON EL ARCHIVO CSV""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"# Se abre el archivo datos.csv en modo de lectura      archivo_csv = open("datos.csv", "r")   # Se lee el archivo como diccionario datos = csv.DictReader(archivo_csv)# Se convierte el objeto datos a una lista para que se pueda manejartransacciones = list(datos)# Se cierra el archivoarchivo_csv.close()"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""DEFINICIÓN DE FUNCIONES""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""Funciones para extraer información de las bases de datos"#Función para filtrar la base de datosdef filtrar(datos, diccionario):    if type(diccionario) != type(dict()):        raise TypeError(f"El argumento diccionario debe se de tipo {type(dict())}")    lista = []    for linea in datos:        insertar = True        for llave in diccionario:            if linea[llave] != diccionario[llave]:                insertar = False                break        if insertar:            lista.append(linea)    return lista#Función para obtener los valores únicos que contiene una columna de los datos"def valores_unicos(datos, columnas):    conjunto = set()    for linea in datos:        if type(columnas) == type("str"):            conjunto.add(linea[columnas])                elif type(columnas) in [type([1,2]), type((1,2))]:            lista = []            for columna in columnas:                lista.append(linea[columna])            conjunto.add(tuple(lista)) #Se usa un conjunto para evitar valores repetidos            return conjunto # Esta función regresa el valor total todas las transacciones en# una lista de datos      def valor_total(datos):    cuenta = 0    for transaccion in datos:        cuenta += float(transaccion['total_value'])    return cuenta    # Esta función sólo se enfoca en los dos países en los cuales se da una transacciondef datos_sin_direccion(datos):    lista = []    for linea in datos:        paises = tuple(sorted((linea["origin"],linea["destination"])))        dic = {'register_id': linea['register_id'], "paises":paises}        for llave in linea.keys():            if llave not in ['register_id',"direction", "origin", "destination"]:                dic[llave] = linea[llave]        lista.append(dic)            return lista       "Funciones para el análisis de la consigna 2"# Función para, de una lista, seleccionar el elemento que generan el percentil de # los valoresdef top_paises_percentil(lista, total_valores, percentil):    top = []    total = 0    for pais in lista:        top.append(pais)        total += pais[1]        if total > total_valores*percentil:            break    return top# Función que generaliza la anterior, filtra los datos y selecciona los# países que generan el 80% de los valores.def top_paises(datos, ubicacion, paises, opcion, percentil, desc = True):        #Código de para candados de la función    if ubicacion not in ["origin", "destination"]:        raise ValueError("El argumento ubiccación debe estar contenido en la lista ['origin', 'destination']")        if opcion not in ['valor total', 'numero transacciones']:        raise ValueError("El argumento opción debe estar contenido en la lista ['valor total', 'numero transacciones']")        if type(desc) != type(True):        raise ValueError(f"El argumento desc deber ser de tipo {type(True)}")        lista = []    for pais in paises:        lista_filtrada = filtrar(datos, {ubicacion:pais})        if opcion == 'valor total':            x = valor_total(lista_filtrada)        else:            x = len(lista_filtrada)        lista.append([pais, x])        lista.sort(key = lambda x: x[1], reverse = desc)        top = []    total = 0    for pais in lista:        top.append(pais)        total += pais[1]        if total > valor_total(datos)*percentil:            break    return top    '''Funciones para obtener información de las listas que se filtranpara calificar las estrategias'''# Esta opción obtiene el número de transacciones o # el total de valores de una listadef desglosar_transacciones(datos, columna, valores, opcion):        if opcion not in ["valor total", "numero transacciones"]:        raise ValueError('El argumento opcion sólo puede tomar valores en la lista ["valor total", "numero transacciones"]')        valores_tupla = tuple(valores)    lista = [0 for x in valores_tupla]    llaves = (str(x) for x in valores_tupla)    for linea in datos:        x = linea[columna]        if x in valores_tupla:            indice = valores_tupla.index(x)            if opcion == "valor total":                lista[indice] += float(linea['total_value'])            elif opcion == "numero transacciones":                lista[indice] += 1    dic = dict(zip(llaves, lista))    return dic# Función para juntar la información de una estrategiadef obtener_info(lista, datos, llaves, opcion, nombre = "Elemento",                 ver_transportes = True, ver_anios = True):    if type(llaves) not in [type(tuple()), type(list()), type(str())]:        raise TypeError(f"El argumento llaves debe de ser de tipo {type(tuple()), type(list(), type(str))}")        lista_info = []    for x in lista:                if type(llaves) == type(str()):            lista_filtrada = filtrar(datos, {llaves:x[0]})                if type(llaves) in [type(tuple()), type(list())]:                    dic = {}            for i in range(len(x[0])):                dic[llaves[i]] = x[0][i]                        lista_filtrada = filtrar(datos, dic)                if opcion == "valor total":            total_valores = x[1]            numero_transacciones = len(lista_filtrada)        else:            numero_transacciones = x[1]            total_valores = valor_total(lista_filtrada)                dic = {nombre:x[0], "Transacciones":numero_transacciones,               "Valor total":total_valores}                    if ver_transportes:            transportes = valores_unicos(lista_filtrada, "transport_mode")            transacciones_trans = desglosar_transacciones(lista_filtrada, "transport_mode",                                                      transportes, "numero transacciones")                    total_trans = desglosar_transacciones(lista_filtrada, "transport_mode", transportes,                                              "valor total")                        dic["Transacciones por transporte"] = transacciones_trans            dic["Valor total por transporte"] = total_trans                        if ver_anios:            anios = sorted(valores_unicos(lista_filtrada, "year"), reverse = True)            transacciones_anio = desglosar_transacciones(lista_filtrada, "year", anios,                                                      "numero transacciones")            total_anio = desglosar_transacciones(lista_filtrada, "year", anios,                                                      "valor total")                        dic["Transacciones por año"] = transacciones_anio            dic["Valor total por año"] = total_anio                                            lista_info.append(dic)            return lista_info"Funciones para la recopiliación de información sobre las estrategias"# Función para crear un diccionario utilizando los elementos de un# conjunto como llaves.def crear_diccionario(conjunto):    # Se asegura que el argumento conjunto sea de tipo <class set>    if type(conjunto) != type(set()):        raise TypeError(f"El argumento conjunto debe ser de tipo {type(set())}")        lista = sorted(list(conjunto), reverse = True)    dic = {}    for x in lista:        dic[x] = 0    return dic # Función para crear un diccionario con los criterios a evaluar# para cada estrategiadef crear_criterios_estrategia():    dic = {"Total valores":0, "Porcentaje valores":0,                 "Total transacciones":0, "Porcentaje transacciones":0,                "Transacciones por transporte":crear_diccionario(MEDIOS_TRANSPORTE),                "Transacciones por año": crear_diccionario(ANIOS)}    return dic# Función para rellenar el diccionario con los datos de una estrategiadef obtener_datos_estrategia(lista, ver_transportes = True, ver_anios = True, proporciones = True):    dic = crear_criterios_estrategia()     for x in lista:        dic["Total valores"] += x["Valor total"]                # Se hace la suma del numero de transacciones de cada ruta        dic["Total transacciones"] += x["Transacciones"]                if ver_transportes:        # Se hace la suma del número de transacciones por transporte de cada ruta            for llave in x["Transacciones por transporte"]:                dic["Transacciones por transporte"][llave] += x["Transacciones por transporte"][llave]                if ver_anios:        # Se hace la suma del número de transacciones por año de cada ruta            for llave in x["Transacciones por año"]:                dic["Transacciones por año"][llave] += x["Transacciones por año"][llave]        if  proporciones:        dic["Porcentaje valores"] = dic["Total valores"]/valor_total(transacciones)                dic["Porcentaje transacciones"] = dic["Total transacciones"]/len(transacciones)    return dic # Función para sumar datos de dos diccionarios distintos, correspondientes# a una estrategia.       def operar_estrategias(estrategia_1, estrategia_2, suma = True, proporciones = True):    estrategia = crear_criterios_estrategia()    for llave in estrategia_1:        if llave in ["Total valores", "Total transacciones"]:            if suma:                estrategia[llave] = estrategia_1[llave] + estrategia_2[llave]            else:                estrategia[llave] = estrategia_1[llave] - estrategia_2[llave]        elif llave in ["Transacciones por transporte", "Transacciones por año"]:            for key in estrategia_1[llave]:                if suma:                    estrategia[llave][key] = estrategia_1[llave][key] + estrategia_2[llave][key]                else:                    estrategia[llave][key] = estrategia_1[llave][key] - estrategia_2[llave][key]    # Si se quiere obtener las proporciones de valores y transacciones    if proporciones:        estrategia["Porcentaje valores"] = estrategia["Total valores"]/valor_total(transacciones)                estrategia["Porcentaje transacciones"] = estrategia["Total transacciones"]/len(transacciones)    return estrategia"Funciones para calificar las estrategias"# Función para obtener los promedios de calificaciones de cada estrategia# según los criterios de tiempo, costo y actividaddef promedio_calificaciones(estrategia,categoria, dic_puntajes):    total = 0    for llave in estrategia[categoria]:        total += estrategia[categoria][llave]*dic_puntajes[llave]      promedio = total/estrategia["Total transacciones"]    return promedio# Función para obtener la calificaci´on final de una estategia.    def obtener_calificacion(estrategia):    if type(estrategia) != type(dict()):        raise TypeError(f"El argumento debe ser de tipo {type(dict())}")        pct_valores = estrategia["Porcentaje valores"]*10*0.3    pct_transacciones = estrategia["Porcentaje transacciones"]*10*2/15    costo = promedio_calificaciones(estrategia, "Transacciones por transporte", costos_transporte)*0.3    tiempo = promedio_calificaciones(estrategia, "Transacciones por transporte", tiempos_transporte)*2/15    actividad = promedio_calificaciones(estrategia, "Transacciones por año", puntajes_anios)*2/15        return pct_valores + pct_transacciones + costo + tiempo + actividad"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""SE DEFINEN ALGUNAS LISTAS DE UTILIDAD GLOBALES""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"# Obtenemos las transacciones sin importar la direcciontransacciones_sin_direccion = datos_sin_direccion(transacciones)# Lista de transacciones catalogadas como importacionimportaciones = filtrar(transacciones, {"direction":'Imports'}) # Lista de transacciones catalogadas como exportacionexportaciones = filtrar(transacciones, {"direction":'Exports'}) "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""SE DEFINEN ALGUNAS VARIABLES GLOBALES""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"#Años en los que se tienen registrosANIOS = valores_unicos(transacciones, "year")ANIOS_LISTA = sorted(list(ANIOS), reverse = True)# Obtenemos los medios de transporte utilizadosMEDIOS_TRANSPORTE = valores_unicos(transacciones, "transport_mode")MEDIOS_TRANSPORTE_LISTA = list(MEDIOS_TRANSPORTE)# Obtenemos las rutas de las transaccionesRUTAS = valores_unicos(transacciones, ("origin", "destination"))# Se convierte el conjunto a una lista por si se necesita iterar sobre éstaRUTAS_LISTA = list(RUTAS) # Se obtienen la combinacion de paoses entre los cuales se ha hecho alguna transaccionCOMB_PAISES = valores_unicos(transacciones_sin_direccion, "paises")# Se convierte el conjunto a una lista por si se necesita iterar sobre éstaCOMB_PAISES_LISTA = list(COMB_PAISES)# Se obtiene el conjunto de los países exportadoresPAISES_EXP = valores_unicos(transacciones, "origin")# Se obtiene el conjunto de países importadoresPAISES_IMP = valores_unicos(transacciones, "destination")# Se obtiene el conjunto de todos los países que aparecen en la lista    PAISES = PAISES_IMP.union(PAISES_EXP)         "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""OPCION 1A ENFOQUE EN RUTAS UNIDIRECCIONAL""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"#Se obtienen el número números de transacciones que cada combinación# unidireccional de países ha tenidorutas_con_direccion = []for ruta in RUTAS_LISTA:    lista_filtrada = filtrar(transacciones, {"origin":ruta[0], "destination":ruta[1]})    rutas_con_direccion.append([ruta, len(lista_filtrada)])#Se ordena la listarutas_con_direccion.sort(key = lambda x: x[1], reverse = True)      # Se obtiene el top10   top10rutas_condireccion = rutas_con_direccion[:10] # Se obtiene la información de cada combinación que aparece en el top10top10rutas_condireccion_info = obtener_info(top10rutas_condireccion, transacciones,                                              ("origin", "destination"), "numero transacciones",                                               "(Origen, Destino)")     # Se resume la información de cada estrategia   opcion1_info = obtener_datos_estrategia(top10rutas_condireccion_info)"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""OPCION 1B ENFOQUE EN RUTAS SIN DIRECCIÓN""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"# Se obtiene el número de transacciones que cada combinación# bidireccional de países ha tenido.rutas_sin_direccion = []for combinacion in COMB_PAISES_LISTA:    lista_filtrada = filtrar(transacciones_sin_direccion, {"paises":combinacion})    rutas_sin_direccion.append([combinacion, len(lista_filtrada)])    # Se ordena la listarutas_sin_direccion.sort(key = lambda x: x[1], reverse = True)# Se obtiene el top10top10rutas_sindireccion = rutas_sin_direccion[:10]    # Se obtiene la información de cada combinación que aparece en el top10top10rutas_sindireccion_info = obtener_info(top10rutas_sindireccion,transacciones_sin_direccion,                                              "paises","numero transacciones", "Paises")   # Sde obtiene la información de la estrategiaopcion1b_info = obtener_datos_estrategia(top10rutas_sindireccion_info)        "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""OPCIÓN 2. ENFOQUE EN MEDIOS DE TRANSPORTE""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"# Se realiza una lista con los valores que cada medio de transporte ha generadotransportes = []for transporte in MEDIOS_TRANSPORTE_LISTA:    lista_filtrada = filtrar(transacciones, {"transport_mode":transporte})    transportes.append([transporte, valor_total(lista_filtrada)])# Se ordena la listatransportes.sort(key = lambda x: x[1], reverse = True)# Se obtiene el top3 de los transportestop3transportes = transportes[:3]# Se obtiene la información de las transacciones en las que se ha estado# usando cada medio de transportetop3transportes_info = obtener_info(top3transportes,transacciones,"transport_mode",                                       "valor total", "Transporte", ver_transportes= False)# Se obtiene la información requerida de la estrategiaopcion2_info = obtener_datos_estrategia(top3transportes_info,ver_transportes=False)# Se rellena la información faltante acerca del número de transacciones que se han# realizado por transportesfor transporte in top3transportes_info:    llave = transporte["Transporte"]    opcion2_info["Transacciones por transporte"][llave] = transporte["Transacciones"]    "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""OPCIÓN 3. ENFOQUE EN PAÍSES QUE MAS IMPORTAN Y EXPORTAN""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"   "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""OPCIÓN 3a. Tomar todos los paises de la lista transacciones""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" #Ordenación de los países de acuerdo al valor total de las transacciones #en las que cada uno participóvalor_total_pais = []for pais in PAISES:    lista_filtrada_1 = filtrar(transacciones, {"origin": pais})        lista_filtrada_2 = filtrar(transacciones, {"destination": pais})        lista_filtrada = lista_filtrada_1 + lista_filtrada_2    # Se añade a una lista el país y los valores que generó durante la transacción    # SE VA A SUPONER QUE CADA PAÍS APORTA LA MITAD DEL VALOR GENERADO    valor_total_pais.append([pais, valor_total(lista_filtrada)/2])# Se ordena la listavalor_total_pais.sort(key = lambda x: x[1], reverse = True)#"Obtención del top 80% de los países partícipes en las transacciones"toppaises = top_paises_percentil(valor_total_pais, valor_total(transacciones), 0.8)#"Expansión de la información de la actividad de cada país"toppaises_info = []for pais in toppaises:    # En este caso se tiene que hacer la unión de dos listras filtraddas    lista_filtrada_1 = filtrar(transacciones, {"origin": pais[0]})    lista_filtrada_2 = filtrar(transacciones, {"destination": pais[0]})        lista_filtrada = lista_filtrada_1 + lista_filtrada_2    # Se obtiene el número de transacciones en las que ha participado cada país    numero_transacciones = len(lista_filtrada)        # Se obtienen los valores que ha generado cada país    total_valores = pais[1]        # Se escribe el código que realiza la función "obtener_info"    anios = sorted(valores_unicos(lista_filtrada, "year"), reverse = True)    transacciones_anio = desglosar_transacciones(lista_filtrada, "year", anios,                                                  "numero transacciones")    total_anio = desglosar_transacciones(lista_filtrada, "year", anios,                                                  "valor total")        transportes = valores_unicos(lista_filtrada, "transport_mode")    transacciones_trans = desglosar_transacciones(lista_filtrada, "transport_mode",                                                  transportes, "numero transacciones")        total_trans = desglosar_transacciones(lista_filtrada, "transport_mode", transportes,                                          "valor total")        dic = {"País":pais[0], "Transacciones":numero_transacciones,           "Valor total":total_valores,           "Transacciones por año":transacciones_anio,           "Valor total por año":total_anio,           "Transacciones por transporte":transacciones_trans,           "Valor total por transporte":total_trans}    toppaises_info.append(dic)"Ahora hay que obtener la informaación de cada combinación de países en la lista anterior""Esto se hace para evitar contar doble una transacción""Primero se obtienen las combinaciones de los países que aparecen en el top 10"combinaciones_paises = []for i in range(len(toppaises) - 1):    for j in range(i+1, len(toppaises)):        pais1  = toppaises[i][0]        pais2 =  toppaises[j][0]        comb = (pais1, pais2)        combinaciones_paises.append(tuple(sorted(comb)))"Se rellenan los datos de cada combinación"  total_combinacion = []for combinacion in combinaciones_paises:    lista = filtrar(transacciones_sin_direccion, {"paises":combinacion})        total_valores = valor_total(lista)    numero_transacciones = len(lista)        # Misma acción que la función obtener_info, pero con un detalle que impide usarla    if numero_transacciones != 0:        anios = sorted(valores_unicos(lista, "year"), reverse = True)        transportes = valores_unicos(lista, "transport_mode")                total_anio = desglosar_transacciones(lista, "year", anios, "valor total")        transacciones_anio = desglosar_transacciones(lista, "year", anios,                                                     "numero transacciones")                total_trans = desglosar_transacciones(lista, "transport_mode", transportes,                                              "valor total")                transacciones_trans = desglosar_transacciones(lista, "transport_mode",                                                      transportes, "numero transacciones")                dic = {"Paises":combinacion, "Transacciones":numero_transacciones,               "Valor total":total_valores,               "Transacciones por año":transacciones_anio,               "Valor total por año":total_anio,               "Transacciones por transporte":transacciones_trans,               "Valor total por transporte":total_trans}                total_combinacion.append(dic)         # Resumen de las operaciones por paísresumen_pais = obtener_datos_estrategia(toppaises_info, proporciones = False)# Resumen de las operaciones por combinaciónresumen_comb = obtener_datos_estrategia(total_combinacion)# Se restan las transacciones para evitar el conteo dobleopcion3a_info = operar_estrategias(resumen_pais, resumen_comb, suma=False, proporciones = False)'''Al aplicar la función anterior se restó el valor de las transacciones, por loque hay que regresarlo a su valor original. Esto se debe a que a cada país se le asignóla mitad del valor de de la transacción'''opcion3a_info["Total valores"] += resumen_comb["Total valores"]# Se obtienen las proporcionesopcion3a_info["Porcentaje valores"] = opcion3a_info["Total valores"]/valor_total(transacciones)opcion3a_info["Porcentaje transacciones"] = opcion3a_info["Total transacciones"]/len(transacciones)"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""OPCIÓN 3b. Tomar los paises por separado""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" # De la lista que contiene sólo las importaciones, se hace un conjunto de los países# exportadores. PAISES_EXP_1 = valores_unicos(exportaciones, "origin")# De la lista que contiene sólo las importaciones, se hace un conjunto de los países# importadoresPAISES_IMP_1 = valores_unicos(importaciones, "destination")# De la lista que contiene sólo las exportaciones, se obtiene el top 80% de los países# exportadorestoppaises_exp = top_paises(exportaciones, "origin", PAISES_EXP_1, "valor total", 0.8)# De la lista que contiene sólo las exportaciones, se obtiene el top 80% de los países# exportadorestoppaises_imp = top_paises(importaciones, "destination", PAISES_IMP_1, "valor total", 0.8)# Información de las transacciones en los que participaron cada uno de los países exportadorestoppaises_exp_info = obtener_info(toppaises_exp, exportaciones, "origin", "valor total",                                       "País")# Información de las transacciones en los que participaron cada uno de los países importadorestoppaises_imp_info = obtener_info(toppaises_imp, importaciones, "destination",                                    "valor total", "País")# Se obtienen los resúmenes de las transacciones en las que participaron los# diferentes tipos de países.resumen_toppaises_exp = obtener_datos_estrategia(toppaises_exp_info)resumen_toppaises_imp = obtener_datos_estrategia(toppaises_imp_info)# Se obtienen los datos de la estrategiaopcion3b_info = operar_estrategias(resumen_toppaises_exp, resumen_toppaises_imp)"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""EVALUACIÓN DE LAS ESTRATEGIAS""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" # Creación un diccionario para calificar el tiempo que toma la estrategiatiempos_transporte = crear_diccionario(MEDIOS_TRANSPORTE)# Se rellena el diccionariotiempos_transporte['Air'], tiempos_transporte['Sea'] = 10, 4tiempos_transporte['Rail'], tiempos_transporte['Road'] = 8, 6# Creación un diccionario para calificar el costo que implica una esrategiacostos_transporte = crear_diccionario(MEDIOS_TRANSPORTE)# Relleno del diccionariocostos_transporte['Air'], costos_transporte['Sea'] = 4, 8costos_transporte['Rail'], costos_transporte['Road'] = 10, 6# Creación de un diccionario para calificar la actividad de una estrategiapuntajes_anios = crear_diccionario(ANIOS)# Relleno del diccionariopuntajes_anios["2015"], puntajes_anios["2016"], puntajes_anios["2017"] = 5,6,7puntajes_anios["2018"], puntajes_anios["2019"], puntajes_anios["2020"] = 8,9,10# Se crea una lista con la estrategia a evaluarestrategias = [opcion1_info, opcion1b_info, opcion2_info, opcion3a_info,opcion3b_info]# Se crean los nombres de las estrategiasnombres_estrategias = ["Opción 1", "Opción 1b", "Opción 2", "Opción 3a", "Opción 3b"]# Se obtiene la calificación de cada estrategiacalificaciones_estrategias = []for estrategia in estrategias:    calificacion = obtener_calificacion(estrategia)    calificaciones_estrategias.append(calificacion)# Se ordenan las estrategiass de acuerdo a la calificación obtenida.calificaciones_finales = list(zip(nombres_estrategias, calificaciones_estrategias))calificaciones_finales.sort(key = lambda x:x[1], reverse = True)    "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++""MUESTRA DE LA INFORMACIÓN""+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" #Función para desplegar la información contenida en un arreglodef desplegar_arreglo(arreglo):    print("\n\n")    for x in arreglo:        if type(arreglo) == type(dict()):            print(x,":",arreglo[x])            print("\n")        else:                print(x)            print("\n")"CALIFICACIONES ESTRATEGIAS"# Muestra de manera ordenada la calificación que obtuvo cada estrategia#desplegar_arreglo(calificaciones_finales)                "OPCIÓN 1A"    #Mostrar las mejores 10 rutas unidireccionales y el número de transacciones realizadas#desplegar_arreglo(top10rutas_condireccion)# Mostrar la información de cada ruta en el top 10#desplegar_arreglo(top10rutas_condireccion_info)# Mostrar la información de la estrategia 1a#desplegar_arreglo(opcion1_info)"OPCIÓN 1B"#Mostrar las mejores 10 rutas biidireccionales y el número de transacciones realizadas#desplegar_arreglo(top10rutas_sindireccion)# Mostrar la información de cada ruta en el top 10#desplegar_arreglo(top10rutas_sindireccion_info)# Mostrar la información de la estrategia 1a#desplegar_arreglo(opcion1b_info)"OPCIÓN 2"# Mostrar el top 3 de los medios de transportes de acuerdo a los valores que# se generaron#desplegar_arreglo(top3transportes)# Mostrar la información de cada transporte en eln top 3#desplegar_arreglo(top3transportes_info)#Mostrar la información de la estrategia#desplegar_arreglo(opcion2_info)"OPCIÓN 3A"# Mostrar los países que comprenden el 80% de los ingresos sin importar# si fueron el exportador o importador#desplegar_arreglo(toppaises)# Mostrar la información de las operaciones en las que estuvo# involucrado cada país contenido en la estrategia#desplegar_arreglo(toppaises_info)#Mostrar la información de la estrategia.#desplegar_arreglo(opcion3a_info)"OPCIÓN 3B"#Mostrar los países que generaron el 80% de las importaciones y exportaciones# de acuerdo con la dirección de la transacción.#print("\nPaíses exportadores:")#desplegar_arreglo(toppaises_exp)#print("***************")#print("\nPaíses importadores")#desplegar_arreglo(toppaises_imp)# Mostrar la información detallada de las transacciones en las que estuvieron #involucrados los países#print("\nPaíses exportadores:")#desplegar_arreglo(toppaises_exp_info)#print("***************")#print("\nPaíses importadores")#desplegar_arreglo(toppaises_imp_info)#Mostrar la información de la estrategia#desplegar_arreglo(opcion3b_info)        